# SpiritSync.SqlRawGenerator

A C# incremental source generator that will generate a string constant with the full text of any interpolated SQL string populated with compile-time or statically-accessible values.

## Use Case

Some teams prefer the simplicity, readability, and *reasonability* that comes with having raw SQL code written directly in C# code with minimal abstractions (just ADO.NET) and absolutely minimal third-party code.

1. You aren't beholden to a third-party API's vulnerabilities or updates.
1. You aren't limited by the supported SQL syntax of a C# library.
1. You have the best possible performance when building SQL queries from C# code.
1. You can clearly observe and reason about the expected behavior with zero abstractions between you and the SQL code.
1. You can directly copy/paste queries from C# code into a SQL browser and run them to debug behavior.

In such cases, when you have many queries that share logic, any attempt to centralize the development and maintenance of the SQL code necessarily subverts the above priorities.

This source generator bridges the gap, identifying interpolated SQL strings in your code and recursively tracing the `static`, `const`, and/or literal values embedded within them to generate a full copy-pasteable version as a `public const string` property.

## Usage

Below is a sample where the SELECT statement for several queries is intended to be shared, rather than having one larger complex query.

Within a `partial` class declaration, attach the `[RawSql]` attribute to any method containing a string variable named `sql`. This will generate a `public const string` field with the name `{MethodName}RawSql`.

```csharp
namespace MyProject;

public partial class UserStore
{
    [RawSql]
    public async Task<List<User>> GetUsersByEmail(string email)
    {
        await using var connection = CreateConnection();

        // Declare a variable named `sql`. It can also be a `const string`.
        var sql = $"""
            SELECT 
                {UserFields("u")}
            FROM users u
            WHERE u.email = :email
            """;

        // Assign generated constant as SQL text to execute.
        var cmd = connection.CreateCommand()
        {
            CommandText = GetUsersByEmailRawSql,
        };

        // ...setup, execution, and return omitted for brevity.
    }

    [RawSql]
    public async Task<List<User>> GetUsersByName(string name)
    {
        await using var connection = CreateConnection();

        var sql = $"""
            SELECT 
                {UserFields("u")}
            FROM users u
            WHERE u.username = name:
            """;

        var cmd = connection.CreateCommand()
        {
            CommandText = GetUsersByNameRawSql,
        };

        // etc.
    }

    private static string UserFields(string alias) => $"""
            {alias}.id AS Id,
            {alias}.email AS Email,
            {alias}.username AS Name,
            {alias}.is_enabled AS IsEnabled
    """;
}
```

Because they are constants, you can hover over the constant's symbol with your mouse to have your IDE display a preview of its value.

The resulting generated file uses the template `{ClassName}_{MethodName}_RawSql.g.cs`.

The sample above would generate one file for each of the methods declared with the attribute. For example, `UserStore_GetUsersByEmail_RawSql.g.cs` would have the below content:

```csharp
// <auto-generated/>
namespace MyProject
{
    public partial class UserStore
    {
        <summary>
        <para>
        Computed value from interpolated string.
        </para>
        <para>
        Source: <see cref="MyProject.UserStore.GetUsersByEmail(string)" />
        </para>
        <para>
        From: C:\Users\John_Smith\source\repos\MyProject\src\MyProject\Store\UserStore.cs (line 12), var sql
        </para>
        </summary>
        public const string GetUsersByEmailRawSql =
            """
            SELECT
                u.id AS Id,
                u.email AS Email,
                u.username AS Name,
                u.is_enabled AS IsEnabled
            FROM users u
            WHERE u.email = :email
            """;
    }
}
```

If you have multiple variables within the same method that need to be generated, then you can simply declare the attribute a second time.
Its constructor allows you to override the variable name it searches for ("sql" by default) and the name of the constant that is generated (the method name + "RawSql" by default):

```csharp
namespace MyProject;

public partial class SiteStore
{
    [RawSql]
    [RawSql("countSql", $"{nameof(ClearSiteCache)}CountRawSql")]
    public async Task ClearSiteCache()
    {
        const string sql = $"DELETE FROM cache WHERE key = '{SiteData.CacheKey}'";

        var countSql = $"""
            SELECT COUNT(*)
            FROM cache c
            -- Omitted for brevity
            """;

        // Some validation logic...
    }

    public static class SiteData
    {
        public const string CacheKey = "MyProject:SiteCacheData";
    }
}
```

```csharp
// <auto-generated/>
namespace MyProject
{
    public partial class SiteStore
    {
        <summary>
        <para>
        Computed value from interpolated string.
        </para>
        <para>
        Source: <see cref="MyProject.SiteStore.ClearSiteCache()" />
        </para>
        <para>
        From: C:\Users\John_Smith\source\repos\MyProject\src\MyProject\Store\SiteStore.cs (line 9), var sql
        </para>
        </summary>
        public const string ClearSiteCacheRawSql =
            """
            DELETE FROM cache WHERE key = 'MyProject:SiteCacheData'
            """;

        <summary>
        <para>
        Computed value from interpolated string.
        </para>
        <para>
        Source: <see cref="MyProject.SiteStore.ClearSiteCache()" />
        </para>
        <para>
        From: C:\Users\John_Smith\source\repos\MyProject\src\MyProject\Store\SiteStore.cs (line 11), var countSql
        </para>
        </summary>
        public const string ClearSiteCacheCountRawSql =
            """
            SELECT COUNT(*)
            FROM cache c
            -- Omitted for brevity
            """;
    }
}
```

## Static Tracing

When embedding static method invocations defined in other files, it will trace the arguments passed into the method recursively, evaluating constants, static fields, ternary expressions, local variable declarations, and diving into static method calls, and plug all of the results into the string template returned by the static method. Everything should work provided it can be analyzed statically at build time.

To see this in action, let's make some static helper methods that build a materialized view out of JSON data for an old Oracle database.

```csharp
namespace MyProject;

public static class SqlUtil
{
    /// <summary>
    /// Defines a common table expression that forces a JSON string containing an array of <c>NUMBER</c> or <c>VARCHAR2(100)</c> values to become a materialized view.
    /// </summary>
    /// <param name="alias">The name given to the CTE.</param>
    /// <param name="jsonParameterName">The name of the JSON parameter, excluding any leading colon.</param>
    /// <param name="column">The alias given to the column name.</param>
    /// <param name="varchar">If <c>true</c>, the JSON array values are cast to <c>VARCHAR2(100)</c> instead of to <c>NUMBER</c>.</param>
    /// <param name="varcharLength">Overrides the length of the <c>VARCHAR2</c> cast operation. Defaults to <c>100</c>.</param>
    /// <returns></returns>
    public static string JsonArrayIdListCte(string alias, string jsonParameterName, string column, bool varchar = false, int varcharLength = 100)
        => JsonArrayIdListCte(alias, jsonParameterName, column, varchar ? $"VARCHAR2({varcharLength})" : "NUMBER");

    /// <summary>
    /// Defines a common table expression that forces a JSON string containing an array of <c>NUMBER</c> or <c>VARCHAR2(100)</c> values to become a materialized view.
    /// </summary>
    /// <param name="alias">The name given to the CTE.</param>
    /// <param name="jsonParameterName">The name of the JSON parameter, excluding any leading colon.</param>
    /// <param name="column">The alias given to the column name.</param>
    /// <param name="sqlType">The exact SQL type to which the JSON values should be cast.</param>
    /// <returns></returns>
    public static string JsonArrayIdListCte(string alias, string jsonParameterName, string column, string sqlType)
    {
        return $"""
            /*+ MATERIALIZE */ {alias} AS (
                SELECT /*+ NO_MERGE */ DISTINCT
                    jt.val AS {column}
                FROM JSON_TABLE(:{jsonParameterName}, '$[*]' COLUMNS (val {sqlType} PATH '$')) jt
            )
            """;
    }
}
```

Now we can use this in a method...

```csharp
namespace MyProject;

public partial class UserStore
{
    [RawSql]
    public async Task<List<User>> FindUsersByEmail(params string[] emails)
    {
        await using var connection = CreateConnection();

        var emailsJson = JsonSerializer.Serialize(emails);
        var parameters = new List<OracleParameter>()
        {
            new(nameof(emailsJson), emailsJson),
        };

        var sql = $"""
            WITH {SqlUtil.JsonArrayIdListCte("emails_list", nameof(emailsJson), "email", true)}
            SELECT
                {UserFields("u")}
            FROM users u
            WHERE EXISTS (SELECT 1 FROM emails_list e WHERE e.email = u.email)
            """;

        var cmd = connection.CreateCommand()
        {
            CommandText = FindUsersByEmailRawSql,
        };

        // omit
    }
}
```

This produces the following generated output:

```csharp
// <auto-generated/>
namespace MyProject
{
    public partial class UserStore
    {
        <summary>
        <para>
        Computed value from interpolated string.
        </para>
        <para>
        Source: <see cref="MyProject.UserStore.FindUsersByEmail(string[])" />
        </para>
        <para>
        From: C:\Users\John_Smith\source\repos\MyProject\src\MyProject\Store\UserStore.cs (line 16), var sql
        </para>
        </summary>
        public const string FindUsersByEmailRawSql =
            """
            WITH /*+ MATERIALIZE */ emails_list AS (
                SELECT /*+ NO_MERGE */ DISTINCT
                    jt.val AS email
                FROM JSON_TABLE(:emailsJson, '$[*]' COLUMNS (val VARCHAR2(100) PATH '$')) jt
            )
            SELECT
                u.id AS Id,
                u.email AS Email,
                u.username AS Name,
                u.is_enabled AS IsEnabled
            FROM users u
            WHERE EXISTS (SELECT 1 FROM emails_list e WHERE e.email = u.email)
            """;
    }
}
```
